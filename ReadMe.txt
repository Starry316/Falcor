对acfCurve:
主要修改在GUI，这些更改应该不需要动，在external/imgui_edit中。根据UI返回的控制点信息（point_data中前8个float，只有中间4个会改变），进行updateMap更改ACF，并将curved ACF存在mpACF内，用于可视化。感觉这些应该都是可以直接用的。

对editMat：
CUDADefines内定义了TEST_MULTI，把原先的mNetInt8Name，mShellHFFileName拓展成了数组，存储所有可能用到的材质。对应的mpShellHF，mpTextureSynthesis和mpNBTFInt8也改成了数组（目前硬编码了两个，要增加的话需要改所有关联的地方的数量）。额外定义了选中的像素mSelectedPixel，需要更改成的材质mMatId，以及是否允许更改mEnableEdit。mEnableEdit是true的时候，通过定义的onMouseEvent函数更改mSelectedPixel。

开了一个mpSelectBuffer用在renderHF时，和targetDim一样大且是4维（由于没有blend相关参数，实际只用了前2维）。在HandleHit或HandleDisplacementHit时，在gSelectBuffer的第1维保存屏幕空间到uv空间的映射，在第0维保存各个uv处的材质ID（目前第0维也是targetDim，但这样可能不太好）。对于屏幕空间内距离gSelectedPixel的距离在100以内的pixel，更改此pixel对应uv空间处的材质ID为gMatId。

可以通过gSelectBuffer得到屏幕上某个pixel对应的uv，以及某个uv对应的材质ID。也就是给定一个pixel，可以得到其对应材质ID，根据这个ID来选中gShellHF或者hfData用于得到不同材质的height。

为了得到多个材质的color，cudaVaildBuffer内不再只存0-1，而是存0（无效时）或材质ID（需要从1开始）。cudaInferPass中mpNBTFInt8数组内所有材质都被执行一遍infer，infer时额外给出当前mpNBTFInt8对应材质，只在当前材质与cudaVaildBuffer中存储材质一致时进行infer（目前只在开启合成时执行这个过程）。